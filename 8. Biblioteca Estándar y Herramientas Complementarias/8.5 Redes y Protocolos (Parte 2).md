
----
- TAG: #Redes #Protocolos #Proyecto 
-----
Seguimos practicando mejor sobre el proyecto que les habia mencionado en el **capitulo(1)**

Este script en Python crea un servidor simple que escucha conexiones entrantes en un puerto específico. Lo hice usando la librería `socket`, que permite trabajar con conexiones de red en Python.

De parte de servidor sería de la siguiente manera:

```python
#!/usr/bin/python3

import socket

def start_server():

	host = 'localhost'
	port = 1234

	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
		s.bind((host, port))
		print(f"\n[+] Servidor en escucha en {host}:{port}")
		conn, addr = s.accept()

		with conn:
			print(f"\n[+] Se ha conectado un nuevo cliente: {addr}")
			while True:
				data = conn.recv(1024)
				if not data:
					break
				conn.sendall(data)

start_server()
```


---
### Desglose del código:

1. **Importar la librería necesaria:**
   ```python
   import socket
   ```
   Aquí, importé la librería `socket`, que es esencial para manejar conexiones de red.

2. **Función `start_server()`:**
   ```python
   def start_server():
   ```
   Esta es la función principal que configura y arranca el servidor.

3. **Configurar el servidor:**
   ```python
   host = 'localhost'
   port = 1234
   ```
   Definí `host` como `'localhost'`, lo que significa que el servidor solo aceptará conexiones desde la misma máquina. `port` es el puerto en el que el servidor estará escuchando, en este caso, el **1234**.

4. **Crear y configurar el socket:**
   ```python
   with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
       s.bind((host, port))
       print(f"\n[+] Servidor en escucha en {host}:{port}")
   ```
   Aquí, creé un socket con `socket.AF_INET`, que indica que usaré IPv4, y `socket.SOCK_STREAM`, lo que significa que usaré TCP como protocolo de transporte. Luego, uní (bind) el socket al host y puerto definidos, y notifiqué que el servidor está en escucha.

5. **Aceptar una conexión entrante:**
   ```python
   conn, addr = s.accept()
   with conn:
       print(f"\n[+] Se ha conectado un nuevo cliente: {addr}")
   ```
   Utilicé `s.accept()` para esperar y aceptar una conexión entrante. Cuando un cliente se conecta, `conn` se convierte en el nuevo socket que manejará la comunicación con ese cliente, y `addr` contiene la dirección del cliente. Luego, imprimí un mensaje indicando que un nuevo cliente se ha conectado.

6. **Recibir y enviar datos:**
   ```python
   while True:
       data = conn.recv(1024)
       if not data:
           break
       conn.sendall(data)
   ```
   Aquí, entré en un bucle donde el servidor está esperando recibir datos del cliente. Utilicé `conn.recv(1024)` para recibir hasta 1024 bytes de datos. Si no se recibe ningún dato (`if not data`), significa que la conexión se ha cerrado y el bucle se rompe. Si se reciben datos, estos se envían de vuelta al cliente con `conn.sendall(data)`, funcionando así como un servidor eco (echo server).

7. **Arrancar el servidor:**
   ```python
   start_server()
   ```
   Finalmente, llamé a la función `start_server()` para arrancar el servidor.

### Resumen:
Este script es un servidor básico que escucha en el puerto 1234 de `localhost`. Una vez que un cliente se conecta, el servidor le devuelve cualquier mensaje que el cliente le envíe, hasta que la conexión se cierra.

---

# Ahora por parte del cliente

Este script en Python es un cliente que se conecta a un servidor que está escuchando en un puerto específico. Lo hice usando la librería `socket`, que es ideal para manejar conexiones de red en Python.

```python
#!/usr/bin/python3

import socket

def start_client():

	host = 'localhost'
	port = 1234

	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
		s.connect((host, port))
		s.sendall(b"Hola, servidor!")
		data = s.recv(1024)

	print(f"n[+] Mensaje recibido del servidor: {data.decode()}")

start_client()
```


---

### Desglose del código:

1. **Importar la librería necesaria:**
   ```python
   import socket
   ```
   Importé la librería `socket`, que es fundamental para crear conexiones de red y comunicarme con el servidor.

2. **Función `start_client()`:**
   ```python
   def start_client():
   ```
   Esta es la función principal del cliente que se encargará de conectarse al servidor.

3. **Configurar la conexión del cliente:**
   ```python
   host = 'localhost'
   port = 1234
   ```
   Definí `host` como `'localhost'`, lo que significa que el cliente intentará conectarse a un servidor en la misma máquina. El `port` es el puerto en el que el servidor está escuchando, en este caso, el **1234**.

4. **Crear y conectar el socket:**
   ```python
   with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
       s.connect((host, port))
   ```
   Creé un socket de tipo `AF_INET` para usar IPv4, y `SOCK_STREAM` para utilizar TCP. Luego, utilicé `s.connect((host, port))` para establecer la conexión con el servidor en la dirección y puerto especificados.

5. **Enviar un mensaje al servidor:**
   ```python
   s.sendall(b"Hola, servidor!")
   ```
   Después de conectar, envié un mensaje al servidor usando `s.sendall(b"Hola, servidor!")`. El prefijo `b` indica que estoy enviando datos en formato de bytes, que es lo que espera el socket.

6. **Recibir la respuesta del servidor:**
   ```python
   data = s.recv(1024)
   ```
   Luego, utilicé `s.recv(1024)` para recibir la respuesta del servidor. Aquí, el cliente espera recibir hasta 1024 bytes de datos.

7. **Mostrar el mensaje recibido:**
   ```python
   print(f"\n[+] Mensaje recibido del servidor: {data.decode()}")
   ```
   Finalmente, decodifiqué los datos recibidos de bytes a texto con `data.decode()` y los imprimí en la consola para mostrar el mensaje que el servidor envió de vuelta.

8. **Arrancar el cliente:**
   ```python
   start_client()
   ```
   Para poner en marcha el cliente, llamé a la función `start_client()`.

### Resumen:
Este script es un cliente simple que se conecta a un servidor en el puerto 1234 de `localhost`, envía un mensaje diciendo "Hola, servidor!" y luego recibe la respuesta del servidor, la cual muestra en la consola.

---

# Ejecución 

Por parte del servidor:

```bash
python3 server.py
```

Por parte del cliente:

```bash
python3 client.py
```

----

# Ejemplo con conexiones **UDP**

Como no es un protocolo pensando en conexiones, lo que se envia son datagramas y no se garantiza que el orden de los paquetes lleguen en el orden correcto o que se reciban todos lo paquetes 

Pero con **UDP** cambia un poco la manera ya que no nos vamos a estar comunicando a través de un socket que entabla en cliente, vamos a tratar directamente con el dato 

La conexión con netcat tambien cambia 

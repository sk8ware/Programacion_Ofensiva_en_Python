
---
- TAG: #Decoradores #Propiedades #Clases 
----
En este apartado vamos a conversar sobre los Decoradores y Propiedades

Tipos de Decoradores hemos visto varios, como:
- `@property` - Se definía en la parte superior de la función para declarar una propiedad, con esta propiedad nos permite crear una propiedad con nombre propio , permitiendonos alterar el comportamiento de una función o de una clase, de manera que no se altera el codigo original de la función original, pero podemos decorarla para que muestre más cosas o realice más operatorias.

Para empezar con el ejercicio, empezamos creando un archivo `exercise.py` con el siguiente ejemplo:

```bash
nvim exercise.py
```

En este caso práctico solo vamos a estar practicando con funciones: 

Imaginemos que tenemos esta función 

```bash
#!/usr/bin/python3

def saludo():
	print("Hola, estoy saludando dentro de la función")

saludo()
```

Pero luego queremos expandirla para que haga otras operatorias antes de llamar a la función y después de llamar también:

Definimos una orden de función superior :

```bash
#!/usr/bin/python3

def mi_decorador(funcion): # Función de orden superior
	def envoltura():
		print("Estoy saludando en la envoltura del decorador antes de llamar a la función")
		funcion() # Llamada a la función original
		print("Estoy saludando en la envoltura del decorador después de llamar a la función")
	return envoltura

@mi_decorador
def saludo():

	print("Hola, estoy saludando dentro de la función")

saludo()
```

Ahora emplearemos otro decorador de propiedades que es `@property` 
Cuando definimos una propiedad por general existe un concepto que es `Getters` y `Setters` y general en el ámbito de python y hay que saber a que nos referimos cuando creamos una propiedad.

**Setter** : Configuar o enviar
**Getter** : Recibir esa configuración

Lo recibe como especie de atributo pero es una propiedad cuidado, pero se crea el método edad para jugar con self, empleamos `slef._edad` dentro de la propiedad ya que esa si seria la manera correcta de usarla y no por fuera.

```bash
#!/usr/bin/python

class Persona:

	def __init__(self, nombre, edad):

		self._nombre = nombre
		self._edad = edad

manolo = Persona("Manolo", 23)
manolo.edad = 19 # Setter
print(manolo.edad) # Getter
```

Si deseamos podemos jugar con este ejemplo y jugar con las edades y tratar que me aparezca un error en específico que nosostros escribamos, eso es lo bueno de las asignaciones, que tenemos control completo de todo de lo que pase 

```bash
#!/usr/bin/python

class Persona:

	def __init__(self, nombre, edad):

		self._nombre = nombre
		self._edad = edad

	@property
	def edad(self): # Getter
		return self._edad

	@edad.setter # Setter
	def edad(self, valor):
		if valor > 0:
			self._edad = valor
		else:
			raise ValueError("[!] La edad no puede ser 0 o un número negativo")

manolo = Persona("David", 23)
manolo.edad = -19 # Setter
print(manolo.edad) # Getter
```

Vamos emplear otro ejemplo :

Estaremos empleando la importación de librerías, practicamente es por donde vamos a utilizar una función que nos permita hacer pausas como en bash al hacer 

```bash
sleep 5 
```

que tarda 5 segundo y te regresa a la consola, seria lo mismo al crear la siguiente librería

```bash
#!/usr/bin/python3

import time

time.sleep(5)
```

Ahora si jugamos con funciones seria de la siguiente manera

```bash
#!/usr/bin/python3

import time

def pausa_corta():
	time.sleep(1)
def pausa_larga():
	time.sleep(3)

pausa_corta()
pausa_larga()
```

Al finalizar vemos que se ejecuta pero no vemos ninguna información, asi que le añadiremos unas funciones para que nos muestre por consola en tiempo real lo que opera por detras

```python
#!/usr/bin/python3

import time

def cronometro(funcion):
	def envoltura(num):
		inicio = time.time()
		funcion(num)
		final = time.time()

		print(f"Tiempo total transcurrido en la función {funcion.__name__}: {final - inicio}")

	return envoltura

@cronometro
def pausa_corta(num):
	time.sleep(num)

@cronometro
def pausa_larga(num):
	time.sleep(num)

pausa_corta(2)
pausa_larga(3)
```

Existe una nomenclatura que nos permite recibir todos los objetos de la funcion `pausa_corta()` como si fuera una tupla con `*args`

Les explicare de mejor manera en el siguiente ejemplo de suma :

```bash
#!/usr/bin/python3

# *args

def suma(*args):
	return sum(args)

print(suma(2, 3, 4))
```

Ahora tenemos esta otra función llamada `**kwargs` para que cuando pasemos esta sintaxis y pasamos argumentos de pares de clave, valor, debemos contemplarla con el `**`

```bash
#!/usr/bin/python3

# **kwargs

def presentacion(**kwargs):

	print(kwargs)

presentacion(nombre="Kevin", edad=19, profesión="Lammer")
```

Ahora si deseamos iterar por cada elemento del diccionario debemos hacerlo de la siguiente manera:

```bash
#!/usr/bin/python3

# **kwargs

def presentacion(**kwargs):

	for clave, valor in kwargs.items():
		print(f"{clave}: {valor}")

presentacion(nombre="Claudia", edad=19, profesión="Lammer")
```

Si quisieramos utilizar las dos funciones **args** y **kwargs**

Mostrando solo el nombre y agregando la función if

```python
#!/usr/bin/python3

import time

def cronometro(funcion):
	def envoltura(*args, **kwargs):
		inicio = time.time()
		funcion()
		final = time.time()

		print(f"Tiempo total transcurrido en la función {funcion.__name__}: {final - inicio}")
		if 'nombre' in kwargs:
			print(kwargs['nombre'])
	return envoltura

@cronometro
def pausa_corta(*args, **kwargs):
	time.sleep(1)

@cronometro
def pausa_larga(*args, **kwargs):
	time.sleep(2)

pausa_corta(nombre="Claudia", edad=34)
pausa_larga()
```

De ultimo ejemplo veremos una clase que se llame `Radio` para repasar y reforzar los decoradores de `Getters` y `Setters`

Utilizando solo `Getters`:

```python
#!/usr/bin/python3

class Circunferencia:

	def __init__(self, radio):
		self._radio = radio

	@property # Getter
	def radio(self):
		return self._radio

	@property # Getter
	def diametro(self):
		return 2 * self._radio

	@property
	def are(self):
		return 3.1415 * (self._radio ** 2)

c = Circunferencia(5)

print(c.radio)
print(c.diametro)
print(round(c.area, 2))
```

Utilizando `Setters`

```python 
#!/usr/bin/python3

class Circunferencia:

	def __init__(self, radio):
		self._radio = radio

	@property # Getter
	def radio(self):
		return self._radio

	@property # Getter
	def diametro(self):
		return 2 * self._radio

	@property
	def are(self):
		return 3.1415 * (self._radio ** 2)

c = Circunferencia(5)

print(c.radio)
print(c.diametro)
print(round(c.area, 2))
```
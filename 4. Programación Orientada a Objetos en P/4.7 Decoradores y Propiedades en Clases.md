
---
- TAG: #Decoradores #Propiedades #Clases 
----
En este apartado vamos a conversar sobre los Decoradores y Propiedades

Tipos de Decoradores hemos visto varios, como:
- `@property` - Se definía en la parte superior de la función para declarar una propiedad, con esta propiedad nos permite crear una propiedad con nombre propio , permitiendonos alterar el comportamiento de una función o de una clase, de manera que no se altera el codigo original de la función original, pero podemos decorarla para que muestre más cosas o realice más operatorias.

Para empezar con el ejercicio, empezamos creando un archivo `exercise.py` con el siguiente ejemplo:

```bash
nvim exercise.py
```

En este caso práctico solo vamos a estar practicando con funciones: 

Imaginemos que tenemos esta función 

```bash
#!/usr/bin/python3

def saludo():
	print("Hola, estoy saludando dentro de la función")

saludo()
```

Pero luego queremos expandirla para que haga otras operatorias antes de llamar a la función y después de llamar también:

```bash
#!/usr/bin/python3

def saludo():
	print("Hola, estoy saludando dentro de la función")

saludo()
```

Definimos una orden de función superior :

```bash
#!/usr/bin/python3

def mi_decorador(funcion): # Función de orden superior
	def envoltura():
	print("Estoy saludando en la envoltura del decorador antes de llamar a la función")
	funtion() # Llamada a la función original
	print("Estoy saludando en la envoltura del decorador después de llamar a la función")
	return envoltura

@mi_decorador
def saludo():

	print("Hola, estoy saludando dentro de la función")

saludo()
```

Ahora emplearemos otro decorador de propiedades que es `@property` 
Cuando definimos una propiedad por general existe un concepto que es `Getters` y `Setters` y general en el ámbito de python y hay que saber a que nos referimos cuando creamos una propiedad.

```bash

```

**Setter** : Configuar o enviar
**Getter** : Recibir esa configuración

Lo recibe como especie de atributo pero es una propiedad cuidado, pero se crea el método edad para jugar con self, empleamos `slef._edad` dentro de la propiedad ya que esa si seria la manera correcta de usarla y no por fuera.

```bash
#!/usr/bin/python

class Persona:

	def __init__(self, nombre, edad):

		self._nombre = nombre
		self._edad = edad

	@property
	def edad(self): # Getter
		return self._edad

	@edad.setter # Setter
	def edad(self, valor):

manolo = Persona("Manolo", 23)
manolo.edad = 19 # Setter
print(manolo.edad) # Getter
```

Si deseamos podemos jugar con este ejemplo y jugar con las edades y tratar que me aparezca un error en específico que nosostros escribamos, eso es lo bueno de las asignaciones, que tenemos control completo de todo de lo que pase 

```bash
#!/usr/bin/python

class Persona:

	def __init__(self, nombre, edad):

		self._nombre = nombre
		self._edad = edad

	@property
	def edad(self): # Getter
		return self._edad

	@edad.setter # Setter
	def edad(self, valor):
		if valor > 0:
			self._edad = valor
		else:
			raise ValueError("[!] La edad no puede ser 0 o un número negativo")

manolo = Persona("David", 23)
manolo.edad = -19 # Setter
print(manolo.edad) # Getter
```

Vamos emplear otro ejemplo :

Estaremos empleando la importación de librerías, practicamente es por donde vamos a utilizar una función que nos permita hacer pausas como en bash al hacer 

```bash
sleep 5 
```

que tarda 5 segundo y te regresa a la consola, seria lo mismo al crear la siguiente librería

```bash
#!/usr/bin/python3

import time

time.sleep(5)
```